#' Sythetic reads generator for genetic variants
#'
#' There are following steps to generate the simulated reads counts for variants
#' in single cells:
#' 1) given the clonal genotype and the clonal prevalence, the genotypes (i.e,
#' the clone) of cells will be generated following a multinormial distribution.
#' Note, one cell may contain variants from two clones when it is a doublet.
#' 2) given the distribution of reads coverage, e.g., a matrix of read coverage
#' from real data, (variant specific), the total reads of each variant will be
#' generated by random sampling. Note, the missing rate is gorvened by this
#' matrix.
#' 3) the allelic frequence of each variant will be generated by following a
#' beta distribution with paramters of mean and varince.
#' 4) Given the genotype of a cell, if the mutation exists in a cell, the
#' alteration read counts will be generated by a binomial distribution,
#' papramitized the allelic frequency, sampled from step 3.
#' 5) Given the genotype of a cell, if the mutation does not exist in a cell,
#' the alteration read counts will be genenrated by a binomial distribution,
#' paramerized by the technical error rate.
#'
#' @export
#'
#' @param Config A matrix of binary values. The clone-variant configuration,
#' whcih encodes the phylogenetic tree structure, and the genotype of each clone
#' @param D A matrix of integers. Sequencing depth for N variants across x
#' cells (ideally >100 cells). NA means 0 here.
#' @param Psi A vector of float. The fractions of each clone. If NULL, set a
#' uniform distribution.
#' @param means A vector of two floats. The mean theta_1 (false positive rate)
#' and the mean theta_2 (true positive rate).
#' @param vars A vector of two floats. The variance of theta_1 and theta_2.
#' @param cell_num A interger. The number of cells to generate.
#' @param permute_D A boolean value. If True permute variants in D.
#' @param wise0 A string, the beta-binomal parameter specificity for theta0:
#' global, variant, element.
#' @param wise1 A string, the beta-binomal parameter specificity for theta1:
#' global, variant, element.
#' @param doublet A float between 0 and 1, the rate of doublets
#'
#' @return a list containing \code{A_sim}, a matrix for alteration reads,
#' \code{A_sim}, a matrix for total reads, \code{I_sim}, a matrix for clonal
#' label, \code{H_sim}, a matrix for genotype, \code{theta0}, a matrix of
#' expected false positive rate, \code{theta1}, a matrix of expected true
#' positive rate, \code{theta0_binom}, theta0 as binomial parameter,
#' \code{theta1_binom}, theta0 as binomial parameter, and \code{is_doublet}, a
#' vector of boolean value if a cell is a doublet
#'
#' @examples
#' data(simulation_input)
#' D2 <- sample_seq_depth(D_input, n_cells=500, n_sites=nrow(tree_4clone$Z))
#' simu <- sim_read_count(tree_4clone$Z, D2, Psi=NULL, cell_num=500)
#'
sim_read_count <- function(Config, D, Psi=NULL,
                           means=c(0.01, 0.47), vars=c(30, 4.8),
                           wise0="element", wise1="variant",
                           cell_num=300, permute_D=FALSE, doublet=0.0){
    M <- cell_num      #number of cells
    K <- ncol(Config)  #number of clones
    N <- nrow(Config)  #number of variants

    shape1s <- means * vars
    shape2s <- (1.0 - means) * vars

    D[which(D == 0)] <- NA
    if (permute_D == TRUE) {
        D <- D[sample(nrow(D)), ]
    }

    # genotype for cells H_sim, and clone labels I_sim
    if (is.null(Psi)) {
        Psi <- rep(1/K, K)
    }
    is_doublet <- rep(FALSE, M)
    is_doublet[sample(M, round(doublet*M))] <- TRUE
    I_sim <- rmultinom(M, 1, prob = Psi)      # Clonal label for each cell
    I_sim[, is_doublet] <- rmultinom(sum(is_doublet), 2, prob = Psi)
    I_sim[which(I_sim > 1)] <- 1
    H_sim <- Config %*% I_sim               # Genotype for each cell

    # generate p, D and A
    p_sim <- matrix(0, 2)      # p1 and p2 for False positive and True positive
    A_sim <- matrix(NA, N, M)  # Alteration counts matrix
    D_sim <- D[, sample(ncol(D), M, replace = TRUE)]
    A_germ_sim <- matrix(NA, N, M)  # Alteration counts matrix for germline var
    D_germ_sim <- matrix(NA, N, M)
    colnames(D_sim) <- NULL
    theta0_Bern_sim <- matrix(NA, N, M)   # theta0 matrix
    theta1_Bern_sim <- matrix(NA, N, M)   # theta1 matrix
    theta0_binom_sim <- matrix(NA, N, M)  # theta0 matrix
    theta1_binom_sim <- matrix(NA, N, M)  # theta1 matrix

    p_sim[1] <- stats::rbeta(1, shape1s[1], shape2s[1])
    p_sim[2] <- stats::rbeta(1, shape1s[2], shape2s[2])
    for (i in seq_len(N)) {
        if (wise0 == "variant") {
            p_sim[1] <- stats::rbeta(1, shape1s[1], shape2s[1])}
        if (wise1 == "variant") {
            p_sim[2] <- stats::rbeta(1, shape1s[2], shape2s[2])}
        for (j in seq_len(M)) {
            if (wise0 == "element") {
                p_sim[1] <- stats::rbeta(1, shape1s[1], shape2s[1])}
            if (wise1 == "element") {
                p_sim[2] <- stats::rbeta(1, shape1s[2], shape2s[2])}
            if (!is.na(D_sim[i,j])) {
                D_germ_sim[i,j] <- D_sim[i,j]
                A_germ_sim[i,j] <- rbinom(1, D_germ_sim[i,j], p_sim[2])

                theta0_binom_sim[i,j] = p_sim[1]
                theta1_binom_sim[i,j] = p_sim[2]
                theta0_Bern_sim[i,j] = 1 - dbinom(0, size = D_sim[i,j], prob = p_sim[1])
                theta1_Bern_sim[i,j] = 1 - dbinom(0, size = D_sim[i,j], prob = p_sim[2])
                if (H_sim[i,j] == 0) {
                    A_sim[i,j] = rbinom(1, D_sim[i,j], p_sim[1])
                }else{
                    A_sim[i,j] = rbinom(1, D_sim[i,j], p_sim[2])
                }
            }
        }
    }
    I_sim <- t(I_sim)
    colnames(I_sim) <- colnames(Config)
    row.names(A_sim) <- row.names(D_sim) <- row.names(Config)
    row.names(A_germ_sim) <- row.names(D_germ_sim) <- row.names(Config)

    cell_names <- paste0("cell", seq_len(ncol(A_sim)))
    row.names(I_sim) <- colnames(A_sim) <- colnames(D_sim) <- cell_names
    colnames(A_germ_sim) <- colnames(D_germ_sim) <- cell_names

    return_list <- list("H_sim" = H_sim, "I_sim" = I_sim,
                        "A_sim" = A_sim, "D_sim" = D_sim,
                        "A_germ_sim" = A_germ_sim, "D_germ_sim" = D_germ_sim,
                        "theta0" = theta0_Bern_sim, "theta1" = theta1_Bern_sim,
                        "theta0_binom" = theta0_binom_sim,
                        "theta1_binom" = theta1_binom_sim,
                        "is_doublet" = is_doublet)
    return_list
}

#' Update matrix D with manully selected missing rate
#'
#' Given missing rate, the NA will be generated first. For none NA element,
#' sequencing depth with uniformly sampled from D, row wisely. Namely, the depth
#' is variant specific.
#'
#' @param D A matrix (N variants x M cells), the orignal sequencing coverage,
#' NA means missing
#' @param n_cells A integer, the number of the cells to generate
#' @param n_sites A integer, the number of variants to generate
#' @param missing_rate A float value, if NULL, use the same missing rate as D
#' @return a n_sites by n_cells matrix sampled from input D.
#'
#' @export
#' @examples
#' data(simulation_input)
#' D1 <- sample_seq_depth(D_input, n_cells=500, n_sites=50, missing_rate=0.85)
#'
sample_seq_depth <- function(D, n_cells=NULL, n_sites=NULL, missing_rate=NULL){
    D[which(D == 0)] <- NA
    if (is.null(n_cells)) {
        n_cells <- ncol(D)
    }
    if (is.null(n_sites)) {
        n_sites <- nrow(D)
    }
    missing_vector <- rowMeans(is.na(D))
    if (!is.null(missing_rate)) {
        if (missing_rate >= 1.0) {
            stop("missing rate should be < 1.0!")
        }
        m_upbound <- 1 - 1.0 / n_cells
        m_mean <- mean(missing_vector)
        amplify <- min(missing_rate / m_mean,
                       (m_upbound - missing_rate) / (max(missing_vector) - m_mean))
        missing_vector <- amplify * (missing_vector - m_mean) + missing_rate
    }

    idx <- sample(nrow(D), size = n_sites, replace = (n_sites > nrow(D)))
    D_input <- D[idx, ]
    missing_vector <- missing_vector[idx]

    D_output <- matrix(NA, nrow = n_sites, ncol = n_cells)
    for (i in seq_len(nrow(D_input))) {
        D_no_na <- D_input[i, which(!is.na(D_input[i,]) & D_input[i,] > 0)]
        D_output[i, ] <- sample(D_no_na, n_cells, replace = TRUE)
        missing_idx <- sample(n_cells, round(missing_vector[i] * n_cells),
                              replace = FALSE)
        D_output[i, missing_idx] <- NA
    }

    D_output
}


#' Down sample number of SNVs in the tree
#'
#' @param tree A tree object from Canopy
#' @param n_SNV A integer, the number of SNVs to keep in the output tree
#' @return a phylo tree with down sampled variants
#'
#' @export
#' @examples
#' data(simulation_input)
#' tree_lite <- sample_tree_SNV(tree_4clone, n_SNV=10)
#'
sample_tree_SNV <- function(tree, n_SNV=NULL){
    total_SNV <- nrow(tree$Z)
    if (is.null(n_SNV)) {
        n_SNV <- total_SNV
    }
    if (total_SNV < n_SNV) {
        stop("Only support down sample SNVs")
    }
    idx <- sample(total_SNV, size = n_SNV)

    out.tree <- tree
    out.tree$Z <- out.tree$Z[idx,]
    out.tree$CCF <- out.tree$CCF[idx,,drop = FALSE]
    out.tree$VAF <- out.tree$VAF[idx,,drop = FALSE]
    out.tree$sna <- out.tree$sna[idx,,drop = FALSE]

    out.tree
}



#' Sythetic reads generator for genetic variants
#' 
#' There are following steps to generate the simulated reads counts for variants
#' in single cells:
#' 1) given the clonal genotype and the clonal prevalence, the genotypes (i.e, 
#' the clone) of cells will be generated following a multinormial distribution. 
#' 2) given the distribution of reads coverage, e.g., a matrix of read coverage 
#' from real data, (variant specific), the total reads of each variant will be 
#' generated by random sampling. Note, the missing rate is gorvened by this 
#' matrix.
#' 3) the allelic frequence of each variant will be generated by following a 
#' beta distribution with paramters of mean and varince.
#' 4) Given the genotype of a cell, if the mutation exists in a cell, the 
#' alteration read counts will be generated by a binomial distribution, 
#' papramitized the allelic frequency, sampled from step 3.
#' 5) Given the genotype of a cell, if the mutation does not exist in a cell, 
#' the alteration read counts will be genenrated by a binomial distribution,
#' paramerized by the technical error rate.
#' 
#' @export
#' 
#' @param C A matrix of binary values. The clone-variant configuration, whcih 
#' encodes the phylogenetic tree structure, and the genotype of each clone.
#' @param D A matrix of integers. Sequencing depth for N variants across x 
#' cells (ideally >100 cells). NA means 0 here.
#' @param Psi A vector of float. The fractions of each clone. If NULL, set a 
#' uniform distribution.
#' @param means A vector of two floats. The mean theta_1 (false positive rate) 
#' and the mean theta_2 (true positive rate).
#' @param vars A vector of two floats. The variance of theta_1 and theta_2.
#' @param cell_num A interger. The number of cells to generate.
#' @param permute_D A boolean value. If True permute variants in D.
#' 
#' @return a list containing \code{A_sim}, a matrix for alteration reads, 
#' \code{A_sim}, a matrix for total reads, \code{I_sim}, a matrix for clonal 
#' label, \code{H_sim}, a matrix for genotype, \code{theta1}, a matrix of 
#' expected false positive rate, and \code{theta2}, a matrix of expected true 
#' positive rate.
#' 
sim_read_count <- function(C, D, Psi=NULL, means=c(0.01, 0.50), 
                           vars=c(18.99, 1.63), cell_num=300, permute_D=FALSE){
  M <- cell_num   #number of cells
  K <- dim(C)[2]  #number of clones
  N <- dim(C)[1]  #number of variants
  
  shape1s <- means / vars
  shape2s <- 1.0 / vars - shape1s
  
  if (permute_D == TRUE){
    D <- D[sample(nrow(D)), ]
  }
  
  # genotype for cells H_sim, and clone labels I_sim
  if(is.null(Psi)){
    Psi <- rep(1/K, K)
  }
  I_sim <- rmultinom(M, 1, prob=Psi) # Clonal label for each cell
  H_sim <- C %*% I_sim               # Genotype for each cell
  
  # generate p, D and A
  p_sim <- matrix(0, 2)      # p1 and p2 for False positive and True positive
  A_sim <- matrix(NA, N, M)  # Alteration counts matrix
  D_sim <- D[, sample(ncol(D), M, replace=T)]
  A_germ_sim <- matrix(NA, N, M)  # Alteration counts matrix for germline var
  D_germ_sim <- matrix(NA, N, M)
  colnames(D_sim) <- NULL
  theta1_Bern_sim <- matrix(NA, N, M)   # theta1 matrix
  theta2_Bern_sim <- matrix(NA, N, M)   # theta2 matrix
  theta1_binom_sim <- matrix(NA, N, M)  # theta1 matrix
  theta2_binom_sim <- matrix(NA, N, M)  # theta2 matrix
  for (i in seq_len(N)){
    for(j in seq_len(M)){
      p_sim[1] <- rbeta(1, shape1s[1], shape2s[1])
      p_sim[2] <- rbeta(1, shape1s[2], shape2s[2])
      if(!is.na(D_sim[i,j])){
        D_no_na <- D[i, (!is.na(D[i,]))]
        D_sim[i,j] <- sample(D_no_na, 1, replace = TRUE)
        D_germ_sim[i,j] <- D_sim[i,j]
        A_germ_sim[i,j] <- rbinom(1, D_germ_sim[i,j], p_sim[2])
        
        theta1_binom_sim[i,j] = p_sim[1]
        theta2_binom_sim[i,j] = p_sim[2]
        theta1_Bern_sim[i,j] = 1 - dbinom(0, size=D_sim[i,j], prob=p_sim[1])
        theta2_Bern_sim[i,j] = 1 - dbinom(0, size=D_sim[i,j], prob=p_sim[2])
        if (H_sim[i,j] == 0){
          A_sim[i,j] = rbinom(1, D_sim[i,j], p_sim[1])
        }else{
          A_sim[i,j] = rbinom(1, D_sim[i,j], p_sim[2])
        }
      }
    }
  }
  return_list <- list("H_sim"=H_sim, "I_sim"=t(I_sim),
                      "A_sim"=A_sim, "D_sim"=D_sim,
                      "A_germ_sim"=A_germ_sim, "D_germ_sim"=D_germ_sim,
                      "theta1"=theta1_Bern_sim, "theta2"=theta2_Bern_sim,
                      "theta1_binom"=theta1_binom_sim, 
                      "theta2_binom"=theta2_binom_sim)
  return_list
}

#' Update matrix D with manully selected missing rate
#' 
#' @export
#' 
missing_update <- function(D, missing_rate=NULL){
  D_tmp <- D
  if(is.null(missing_rate)){
    missing_rate = mean(is.na(D))
  }
  for (i in seq_len(dim(D)[1])){
    D_no_na <- D[i, which(D[i,]>0)]
    missing_num <- round(missing_rate * dim(D)[2])
    samp_pool <- c(rep(NA, missing_num), sample(D_no_na, dim(D)[2]-missing_num, 
                                                replace = TRUE))
    D_tmp[i, ] = sample(samp_pool, dim(D)[2], replace = TRUE)
  }
  D_tmp
}
